<!DOCTYPE html>

<head>
    <title>Shatter</title>

    <link rel="stylesheet" href="../CSS/theme-index.css" />
    <link rel="stylesheet" href="../CSS/index.css" />
    <link rel="stylesheet" href="../CSS/chat.css" /> 
    <link rel="icon" type="image/x-icon" href="../UI/favicon.ico" />

    <!-- main js stuff, copy paste -->
    <script src="../JS/supabase.js"></script>
    <script src="../JS/accounts.js"></script>
    <script src="../JS/fetch.js"></script>
    <script src="../JS/main.js" type="module"></script>

    <loading></loading>
    <admin-req></admin-req>

    <style>
        html {
            overflow-x: hidden;
        }
    </style>
</head>

<body>
    <div class="background"></div>
    <div class="home_menu">
        <div class="profile">
            <img draggable="false" id="pfp">
            <h2 id="username"></h2>
            <script type="module">
                const profile = await FDB("profiles");
                const pfp = profile[0].pfp;
                if (pfp != null && pfp.length > 8) {
                    const { data, error } = await supabaseClient.storage
                        .from("profilePictures")
                        .createSignedUrl(pfp, 60);
                    if (error) {
                        document.getElementById("pfp").src = "../UI/account-placeholder.svg";
                    } else {
                        document.getElementById("pfp").src = data.signedUrl;
                    }
                }
                document.getElementById("username").style.color = profile[0].admin
                    ? "var(--color-uninstall)"
                    : "var(--text-color1)";
                document.getElementById("username").textContent = profile[0].username;
            </script>
        </div>
        <div class="chat_rooms"></div>
        <div class="users" tabindex="-1"></div>
        <div id="overlay" class="overlay">
        </div>
    </div>
    <script type="module">
        window.showLoadingScreen()
	import { api } from "../JS/api.js"
	let emojiMap = {};
	async function fetchEmojiDataset() {
            const response = await fetch('https://cdn.jsdelivr.net/npm/emojibase-data@16.0.2/en/compact.json');
            const emojiData = await response.json();
            emojiData.forEach(item => {
                if (item.label && item.unicode) {
                    emojiMap[item.label] = item.unicode;
                }
            });
        }
	fetchEmojiDataset();
	let room_found = false;
        const user = JSON.parse(localStorage.getItem("sb-fffwukshwgrcdyqmvahg-auth-token"))
        const userId = user.user.id
        const token = user.access_token
        const auth = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZmZnd1a3Nod2dyY2R5cW12YWhnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzEzOTkxMjAsImV4cCI6MjA0Njk3NTEyMH0.MsMeFMkrJCeJzRFWMZXM-CZu8gwaScV7feentsgMQvI'
        const params = new URLSearchParams(window.location.search);
        const currentRoomId = params.get("room");
        let user_statuses = [];
        let clientUser = {};
	let emoteCache = [];
	let oembed_providers;
	function replaceWithEmoji(text) {
	       return text.replace(/:([\w\d_]+):/g, (match, shortcode) => emojiMap[shortcode] || match);
	    }
	try {
		const r = await fetch("../oembed_providers.json"); //I absolutely hate the hell out of this but cors is the worst and won't let me grab it from their api
		oembed_providers = await r.json();
	}catch(e) {
		console.error(e);
		oembed_providers = [];
	}
        try {
            clientUser = JSON.parse(await api({
                "userId": `${userId}`,
                "token": `${token}`,
                "data": `${userId}`,
                "mode": 'fromuid'
            }, auth, "getUser"));
        } catch (error) {
            console.error("userGetError:", error);
        }
        document.addEventListener('click', async (event) => {
            if (event.target && event.target.id === 'joinButton') {
                const name = document.querySelector("#name").value;
                const password = document.querySelector("#password").value;
                if (!name) {
                    alert("Please enter a room name");
                    return;
                }
                try {
                    window.showLoadingScreen()
                    const Idresponse = await api({
                        "userId": `${userId}`,
                        "token": `${token}`,
                        "mode": "fromname",
                        "data": `${name}`
                    }, auth, "getRoom");
                    const id = (JSON.parse(Idresponse))["roomId"];
                    const response = await api({
                        "userId": `${userId}`,
                        "token": `${token}`,
                        "roomId": `${id}`,
                        "password": `${password}`
                    }, auth, "joinRoom");
                    const state = JSON.parse(response);

                    switch (state.message) {
                        case "Room not found":
                            alert("Room not found");
                            break;
                        case "Room is full":
                            alert("Room is full");
                            break;
                        case "User already in room":
                            alert("You are already in this room");
                            break;
                        case "User joined room":
                            window.location.href = `?room=${id}`;
                            break;
                        case "Invalid password":
                            alert("Room not found");
                            break;
                        default:
                            alert("An unknown error occured! =(");
                            break;
                    }
                    window.hideLoadingScreen()
                } catch (error) {
                    window.hideLoadingScreen()
                    console.error("Error joining room:", error);
                    alert("Error joining room =(");
                }
            }
            else if (event.target && event.target.id === 'createSubmit') {
                event.preventDefault()
                const name = document.querySelector("#createName").value;
                const password = document.querySelector("#createPassword").value;
                const isPrivate = document.querySelector("#createPrivate").checked;
                const maxUsers = document.querySelector("#createMaxUsers").value;
                if (!name) {
                    alert('A room name is required')
                    return
                }

                try {
                    window.showLoadingScreen();
                    const response = await api({
                        "userId": `${userId}`,
                        "token": `${token}`,
                        "roomName": `${name}`,
                        "password": `${password}`,
                        "isPrivate": `${isPrivate}`,
                        "maxUsers": `${maxUsers}`
                    }, auth, "createRoom");

                    const state = JSON.parse(response);

                    switch (state.message) {
                        case "Room created":
                            const Idresponse = await api({
                                "userId": `${userId}`,
                                "token": `${token}`,
                                "mode": "fromname",
                                "data": `${name}`
                            }, auth, "getRoom");
                            const id = (JSON.parse(Idresponse))["roomId"];
                            console.log(id)
                            window.location.href = `?room=${id}`;
                            break;
                        default:
                            alert("An unknown error occurred, please try again(room name must be unique)");
                            break;
                    }
                    window.hideLoadingScreen();
                } catch (error) {
                    window.hideLoadingScreen();
                    console.error("Error creating room:", error);
                    alert("Error creating room =(");
                }
            } else if (event.target && event.target.id === 'settingsSubmit') {
		event.preventDefault()
                const name = document.querySelector("#settingsName").value;
                const password = document.querySelector("#settingsPassword").value;
                const isPrivate = document.querySelector("#settingsPrivate").checked;
                const maxUsers = document.querySelector("#settingsMaxUsers").value;
                if (!name) {
                    alert('A room name is required')
                    return
                }

                try {
                    window.showLoadingScreen();
                    const response = await api({
                        "userId": `${userId}`,
                        "token": `${token}`,
                        "roomName": `${name}`,
                        "password": `${password}`,
                        "isPrivate": `${isPrivate}`,
                        "maxUsers": `${maxUsers}`
                    }, auth, "editRoom");

                    const state = JSON.parse(response);

                    switch (state.message) {
                        case "Room edited":
                            break;
                        default:
                            alert("An unknown error occurred, please try again(room name must be unique)");
                            break;
                    }
                    window.hideLoadingScreen();
                } catch (error) {
                    window.hideLoadingScreen();
                    console.error("Error editing room:", error);
                    alert("Error editing room =(");
                }
	    }
        });
        async function loadRooms() {
            let bufferDiv = document.getElementById('bufferDiv');
            if (!bufferDiv) {
                bufferDiv = document.createElement('div');
                bufferDiv.id = 'bufferDiv';
                bufferDiv.style.display = 'none';
                document.body.appendChild(bufferDiv);
            }
            bufferDiv.innerHTML = '';
            const Rooms = JSON.parse(await api({
                "userId": `${userId}`,
                "token": `${token}`
            }, auth, "getRooms"));
            const allRooms = [];
	    const homeDiv = document.createElement("div");
                homeDiv.classList.add("room");
                homeDiv.innerHTML = `
            <h1>Home</h1>
        `;
	if (!currentRoomId || room_found === false) {
	    homeDiv.style.backgroundColor = 'var(--hover-color1)';
	} else {
	    homeDiv.onmouseover = () => {
	        homeDiv.style.backgroundColor = 'var(--color-major)';
	        homeDiv.style.cursor = 'pointer';
	    };
	    homeDiv.onmouseout = () => {
	        homeDiv.style.backgroundColor = '';
	    };
	    homeDiv.onclick = () => {
	        window.location.href = window.location.origin + window.location.pathname;
	    };
	}
            Rooms.rooms.forEach(room => {
                const users = room.users ? JSON.parse(room.users) : [];
                const roomDiv = document.createElement("div");
                roomDiv.classList.add("room");
                roomDiv.innerHTML = `
            <h1>${room.name}</h1>
            <p>Users: ${users.length}/${room.max_users}</p>
        `;
                if (users.length < room.max_users && !users.includes(userId)) {
                    const joinButton = document.createElement("button");
                    joinButton.innerText = "Join";
                    joinButton.onclick = async () => {
                        try {
                            window.showLoadingScreen()
                            const response = await api({
                                "userId": `${userId}`,
                                "token": `${token}`,
                                "roomId": `${room.id}`
                            }, auth, "joinRoom");
                            const state = JSON.parse(response);

                            switch (state.message) {
                                case "Room not found":
                                    alert("Room not found");
                                    break;
                                case "Room is full":
                                    alert("Room is full");
                                    break;
                                case "User already in room":
                                    alert("You are already in this room");
                                    break;
                                case "User joined room":
                                    window.location.href = `?room=${room.id}`;
                                    break;
                                default:
                                    alert("An unknown error occurred");
                                    break;
                            }
                            window.hideLoadingScreen();
                        } catch (error) {
                            window.hideLoadingScreen();
                            console.error("Error joining room:", error);
                            alert("Failed to join room");
                        }
                    };
                    roomDiv.appendChild(joinButton);
                } else if (users.includes(userId)) {
                    if (room.id != currentRoomId) {
                        roomDiv.onmouseover = () => {
                            roomDiv.style.backgroundColor = 'var(--color-major)';
                            roomDiv.style.cursor = 'pointer';
                        };
                        roomDiv.onmouseout = () => {
                            roomDiv.style.backgroundColor = '';
                            roomDiv.style.cursor = '';
                        };
                        roomDiv.onclick = () => {
                            window.location.href = `?room=${room.id}`;
                        }
                    }
                    else {
                        roomDiv.style.backgroundColor = 'var(--hover-color1)';
                    }
                }
                allRooms.push({ isJoined: users.includes(userId), element: roomDiv });
            });
            allRooms.sort((a, b) => b.isJoined - a.isJoined);
            if (allRooms.some(room => room.isJoined)) {
                const joinedSeparator = document.createElement('div');
                joinedSeparator.className = 'separator';
                joinedSeparator.innerText = 'Joined Rooms';
                bufferDiv.appendChild(joinedSeparator);
            }
	    bufferDiv.appendChild(homeDiv);
            allRooms.forEach(room => bufferDiv.appendChild(room.element));
            const firstUnjoinedIndex = allRooms.findIndex(room => !room.isJoined);
            if (firstUnjoinedIndex > 0) {
                const availableSeparator = document.createElement('div');
                availableSeparator.innerText = 'Available Rooms';
                availableSeparator.className = 'separator';
                bufferDiv.insertBefore(availableSeparator, bufferDiv.children[firstUnjoinedIndex + 1]);
            }
            const joinButton = document.createElement('button');
            joinButton.className = 'joinB2';
            joinButton.innerText = 'Join private';
            bufferDiv.appendChild(joinButton);
            const createButton = document.createElement('button');
            createButton.className = 'create';
            createButton.innerText = 'Create room';

            const overlay = document.getElementById('overlay');
            const closeOverlay = document.getElementById('closeOverlay');

            window.onclick = (event) => {
                if (event.target === overlay) {
                    hideOverlay();
                }
            };

            createButton.onclick = () => {
                overlay.innerHTML = `
                    <div class="overlay-content">
                        <h2>Create Room</h2>
                        <form class="join">
                            <input id="createName" placeholder="Room name" required>
                            <input id="createPassword" placeholder="Password(optional)">
                            <div class="createOptions">
                            <h2 id="privateText">Private</h2>
                            <input id="createPrivate" value="off" type="checkbox">
                            <h2 id="maxUsersText">Max users</h2>
                            <input id="createMaxUsers" value="10" type="number" min="2" max="50" required>
                            </div>
                            <button type="submit" id="createSubmit">Create</button>
                        </form>
                    </div>
                `;
                overlay.style.visibility = 'visible';
                overlay.style.opacity = '1';
            };

            bufferDiv.appendChild(createButton);

            joinButton.onclick = () => {
                overlay.innerHTML = `
                    <div class="overlay-content">
                        <h2>Join Private Room</h2>
                        <div class="join">
                            <input id="name" placeholder="Room name">
                            <input id="password" placeholder="Password">
                            <button id="joinButton">Join</button>
                        </div>
                    </div>
                `;
                overlay.style.visibility = 'visible';
                overlay.style.opacity = '1';
            };

            window.addEventListener('keydown', (event) => {
                if (event.key === "Escape") {
                    hideOverlay();
                }
            });

            function hideOverlay() {
                overlay.style.opacity = '0';
                setTimeout(() => overlay.style.visibility = 'hidden', 300);
            }
            document.querySelector(".chat_rooms").replaceChildren(...bufferDiv.children);
            window.hideLoadingScreen()
        }
        async function deleteMessage(id) {
            try {
                window.showLoadingScreen()
                const response = await api({
                    "userId": `${userId}`,
                    "token": `${token}`,
                    "roomId": `${currentRoomId}`,
                    "messageId": `${id}`,
                }, auth, "deleteMessage");
                const state = JSON.parse(response);

                switch (state.message) {
                    case "Room not found":
                        alert("Room not found");
                        break;
                    case "you are not the owner of the message!":
                        alert("you are not the owner of the message!");
                        break;
                    case "Message not found":
                        alert("Message not found");
                        break;
                    case "Message deleted":
                        waitForUpdateFlag = true;
                        return
                        break;
                    default:
                        alert("An unknown error occurred =(");
                        break;
                }
            } catch (error) {
                window.hideLoadingScreen();
                console.error("Error deleting message:", error);
                alert("Failed to delete message =(");
            }
        }
        async function editMessage(id, text, content) {
            try {
                window.showLoadingScreen()
                const response = await api({
                    "userId": `${userId}`,
                    "token": `${token}`,
                    "roomId": `${currentRoomId}`,
                    "messageId": `${id}`,
                    "text": `${text}`,
                    "content": `${content}`,
                }, auth, "editMessage");
                const state = JSON.parse(response);

                switch (state.message) {
                    case "Room not found":
                        alert("Room not found");
                        break;
                    case "you are not the owner of the message!":
                        alert("you are not the owner of the message!");
                        break;
                    case "Message not found":
                        alert("Message not found");
                        break;
                    case "Message edited":
                        waitForUpdateFlag = true;
                        return
                        break;
                    default:
                        alert("An unknown error occurred =(");
                        break;
                }
            } catch (error) {
                window.hideLoadingScreen();
                console.error("Error editing message:", error);
                alert("Failed to edit message =(");
            }
        }

        async function report(data, report, mode) {
            try {
                window.showLoadingScreen()
                const response = await api({
                    "userId": `${userId}`,
                    "token": `${token}`,
                    "roomId": `${currentRoomId}`,
                    "mode": `${mode}`,
                    "data": `${data}`,
                    "report": `${report}`,
                }, auth, "report");
                const state = JSON.parse(response);

                switch (state.message) {
                    case "Room not found":
                        alert("Room not found");
                        break;
                    case "Report must not be empty!":
                        alert("Report must not be empty!");
                        break;
                    case "Message not found":
                        alert("Message not found");
                        break;
		    case "User not found":
                        alert("User not found");
                        break;
                    case "Reported":
                        alert("Reported")
                        return
                        break;
                    default:
                        alert("An unknown error occurred =(");
                        break;
                }
                window.hideLoadingScreen();
            } catch (error) {
                window.hideLoadingScreen();
                console.error("Error reporting:", error);
                alert("Failed to report =(");
            }
        }

	async function kickUser(data) {
            try {
                window.showLoadingScreen()
                const response = await api({
                    "userId": `${userId}`,
                    "token": `${token}`,
                    "roomId": `${currentRoomId}`,
                    "data": `${data}`,
                }, auth, "kickUser");
                const state = JSON.parse(response);

                switch (state.message) {
                    case "Room not found":
                        alert("Room not found");
                        break;
                    case "User not found":
                        alert("User not found");
                        break;
                    case "Kicked":
                        alert("Kicked User")
                        return
                        break;
                    default:
                        alert("An unknown error occurred =(");
                        break;
                }
                window.hideLoadingScreen();
            } catch (error) {
                window.hideLoadingScreen();
                console.error("Error kicking:", error);
                alert("Failed to kick =(");
            }
        }

	async function banUser(data,reason) {
            try {
                window.showLoadingScreen()
                const response = await api({
                    "userId": `${userId}`,
                    "token": `${token}`,
                    "roomId": `${currentRoomId}`,
                    "data": `${data}`,
		    "reason": `${reason}`,
                }, auth, "banUser");
                const state = JSON.parse(response);

                switch (state.message) {
                    case "Room not found":
                        alert("Room not found");
                        break;
                    case "User not found":
                        alert("User not found");
                        break;
		    case "Reason must not be empty!":
                        alert("Reason must not be empty!");
                        break;
                    case "Banned":
                        alert("Banned User")
                        return
                        break;
                    default:
                        alert("An unknown error occurred =(");
                        break;
                }
                window.hideLoadingScreen();
            } catch (error) {
                window.hideLoadingScreen();
                console.error("Error banning:", error);
                alert("Failed to ban =(");
            }
        }

        let pfp_cache = {};
        let user_cache = {};
        let room_cache = {};
        let waitForUpdateFlag = false;
        let inputField;
        let dropdown_cache;
        let editstatus_cache;
        let cancelButton_cache;
        function escCancelEdit(event) {
            if (event.key == 'Escape') {
                cancelButton_cache.click();
            }
        }
        const timeAgo = (timestamp) => {
	    const now = new Date();
	    const time = new Date(timestamp);
	    
	    const seconds = Math.floor((now - time) / 1000);
	    if (seconds < 0) return 'just now';
	
	    const minutes = Math.floor(seconds / 60);
	    const hours = Math.floor(seconds / 3600);
	    
	    const nowDateOnly = new Date(now.getFullYear(), now.getMonth(), now.getDate());
	    const timeDateOnly = new Date(time.getFullYear(), time.getMonth(), time.getDate());
	    const dayDifference = Math.floor((nowDateOnly - timeDateOnly) / 86400000);
	
	    if (dayDifference === 1) {
	        return `yesterday at ${time.toLocaleTimeString(undefined, {
	            hour: '2-digit',
	            minute: '2-digit'
	        })}`;
	    } else if (dayDifference >= 2) {
	        const datePart = time.toLocaleDateString(undefined, {
	            year: '2-digit',
	            month: 'numeric',
	            day: 'numeric'
	        });
	        const timePart = time.toLocaleTimeString(undefined, {
	            hour: '2-digit',
	            minute: '2-digit'
	        });
	        return `${datePart} at ${timePart}`;
	    } else if (hours >= 1) {
	        return `${hours} hour${hours > 1 ? 's' : ''} ago`;
	    } else if (minutes >= 1) {
	        return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
	    } else {
	        return seconds > 0 ? `${seconds} second${seconds > 1 ? 's' : ''} ago` : 'just now';
	    }
	};
        let hideButton; 

async function loadUsers() {
    let usersDiv = document.querySelector('.users');
    usersDiv.setAttribute('tabindex', '-1');
    let bufferDiv = document.createElement('div');

    if (!hideButton) {
        hideButton = document.createElement('button');
        hideButton.className = 'hide-button';
        hideButton.textContent = '◀'; 
        hideButton.onclick = () => toggleUserDivVisibility();
        document.querySelector('.profile').appendChild(hideButton);
    }

    const response = await api({
        "userId": `${userId}`,
        "token": `${token}`,
        "data": `${currentRoomId}`,
        "mode": 'fromid',
    }, auth, "getRoom");

    let room;
    try {
        room = JSON.parse(response);
    } catch (error) {
        console.error("Error parsing room data:", error);
        return;
    }

    const users = room.roomUsers ? JSON.parse(room.roomUsers) : [];

    for (const user_id of users) {
        let user;
        if (!user_cache[user_id]) {
            try {
                user = JSON.parse(await api({
                    "userId": `${userId}`,
                    "token": `${token}`,
                    "data": `${user_id}`,
                    "mode": 'fromuid'
                }, auth, "getUser"));
                user_cache[user_id] = user;
            } catch (error) {
                console.error("Error fetching user data:", error);
                return;
            }
        } else {
            user = user_cache[user_id];
        }

        const userDiv = document.createElement('div');
        userDiv.className = 'user';
        const pfp = document.createElement('img');
        if (!pfp_cache[user_id]) {
            try {
                const { data, error } = await supabaseClient.storage
                    .from("profilePictures")
                    .createSignedUrl(user.pfp, 3600);
                if (!error) {
                    pfp_cache[user_id] = data.signedUrl;
                } else {
                    pfp_cache[user_id] = '../UI/account-placeholder.svg';
                }
            } catch (error) {
                console.error("Error fetching profile picture:", error);
                pfp_cache[user_id] = '../UI/account-placeholder.svg';
            }
        }

        pfp.src = pfp_cache[user_id];
        pfp.draggable = false;
        userDiv.appendChild(pfp);

        const username = document.createElement('h2');
        username.textContent = user.username;
        username.style.color = user.admin
            ? "var(--color-uninstall)"
            : "var(--text-color1)";
        userDiv.appendChild(username);
	if (user_id == room.roomOwner) {
	const crown = document.createElement('div');
	crown.className = 'room-owner'
	crown.title = 'Room owner'
        userDiv.appendChild(crown);
	}
	if (userId != user_id && !user.admin) {
	const menuButton = document.createElement('button');
                    menuButton.className = 'user-menu-button';
                    menuButton.innerHTML = '&#x22EE;'; // vertical dots (⋮)

                    menuButton.onclick = (event) => {
                        event.stopPropagation();
                        closeAllDropdowns();
                        toggleDropdown(menuButton, user);
                    };

                    userDiv.appendChild(menuButton);

                    function toggleDropdown(button, user) {
                        if (dropdown_cache) {
                            dropdown_cache.remove();
                            dropdown_cache = null;
                        } else {
                            let dropdown = document.createElement('div');
                            dropdown.className = 'dropdown-content';
				
                	    if (clientUser.admin || userId == room.roomOwner) {
                            const deleteButton = document.createElement('button');
                            deleteButton.innerText = 'Kick User';
                            deleteButton.onclick = () => {
                                dropdown_cache.remove();
                                dropdown_cache = null;
                                overlay.innerHTML = `
                                    <div class="overlay-content">
                                        <h2>Are you sure you want to kick this user?</h2>
                                        <button id="confirmDelete">Yes</button>
                                        <button id="cancelDelete">No</button>
                                    </div>
                                `;
                                overlay.style.visibility = 'visible';
                                overlay.style.opacity = '1';

                                document.getElementById('confirmDelete').onclick = () => {
                                    kickUser(user_id);
                                    if (cancelButton_cache) {
                                        cancelButton_cache.click();
                                    }
                                    hideOverlay();
                                };

                                document.getElementById('cancelDelete').onclick = hideOverlay;

                                function hideOverlay() {
                                    overlay.style.opacity = '0';
                                    overlay.style.visibility = 'hidden';
                                }
                            };
						const banButton = document.createElement('button');
			                            banButton.innerText = 'Ban User';
			                            banButton.onclick = () => {
							    dropdown_cache.remove();
							    dropdown_cache = null;
							    overlay.innerHTML = `
							        <div class="overlay-content">
							            <h2>Ban User</h2>
							            <textarea id="banReason" placeholder="Reason for banning (required)"></textarea>
							            <button id="confirmBan">Ban</button>
							            <button id="cancelBan">Cancel</button>
							        </div>
							    `;
							    overlay.style.visibility = 'visible';
							    overlay.style.opacity = '1';
							
							    document.getElementById('confirmBan').onclick = () => {
							        const reason = document.getElementById('banReason').value;
							        if (reason.trim() === '') {
							            alert('Please provide a reason for banning');
							            return;
							        }
							        banUser(user_id, reason);
							        hideOverlay();
							    };
							
							    document.getElementById('cancelBan').onclick = hideOverlay;
							
							    function hideOverlay() {
							        overlay.style.opacity = '0';
							        setTimeout(() => overlay.style.visibility = 'hidden', 300);
							    }
							};

                            dropdown.appendChild(deleteButton);
			    dropdown.appendChild(banButton);
			    }
                            const reportUserButton = document.createElement('button');
                            reportUserButton.innerText = 'Report User';
                            reportUserButton.onclick = () => {
                                dropdown_cache.remove();
                                dropdown_cache = null;
                                overlay.innerHTML = `
                                    <div class="overlay-content">
                                        <h2>Report User</h2>
                                        <textarea id="reportUserReason" placeholder="Reason for reporting"></textarea>
                                        <button id="submitUserReport">Submit</button>
                                        <button id="cancelUserReport">Cancel</button>
                                    </div>
                                `;
                                overlay.style.visibility = 'visible';
                                overlay.style.opacity = '1';

                                document.getElementById('submitUserReport').onclick = () => {
                                    const reason = document.getElementById('reportUserReason').value;
                                    if (reason.trim() === '') {
                                        alert('Please provide a reason for reporting');
                                        return;
                                    }
                                    report(user_id, reason, "user");
                                    hideOverlay();
                                };

                                document.getElementById('cancelUserReport').onclick = hideOverlay;

                                function hideOverlay() {
                                    overlay.style.opacity = '0';
                                    setTimeout(() => overlay.style.visibility = 'hidden', 300);
                                }
                            };
                            dropdown.appendChild(reportUserButton);

                            document.querySelector('.home_menu').appendChild(dropdown);
                            const buttonRect = button.getBoundingClientRect();
                            dropdown.style.position = 'absolute';
                            dropdown.style.top = `${buttonRect.bottom}px`;
                            dropdown.style.left = `${buttonRect.left - dropdown.offsetWidth}px`;

                            dropdown_cache = dropdown;
                        }
                    }
		function closeAllDropdowns() {
                        document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                            dropdown.remove();
                        });
                        dropdown_cache = null;
                    }
	}
	const userStatus = user_statuses.find(userStatus => userStatus.user === user_id);
	console.log(userStatus)
        userDiv.style.filter = userStatus ? 'none' : 'grayscale(40%) brightness(60%)';
	    if (userStatus) {
		    if (user_id === userId) {
			const profilePic = document.getElementById("pfp");
			profilePic.style.border = (userStatus.status) ? '4px solid var(--color-accent-2)' : '4px solid var(--color-third)';
		    }
		    pfp.style.border = (userStatus.status) ? '4px solid var(--color-accent-2)' : '4px solid var(--color-third)';
	    }

        if (user_id == userId) {
            userDiv.style.backgroundColor = 'var(--hover-color1)';
            bufferDiv.insertBefore(userDiv, bufferDiv.firstChild);
        } else {
            const color = getComputedStyle(document.documentElement).getPropertyValue('--color-major-lesser');
            userDiv.style.backgroundColor = `${color}40`;
            bufferDiv.appendChild(userDiv);
        }
    }

    const isUsersDivVisible = usersDiv.style.right === '0px';

    if (bufferDiv.children.length > 0) {
        usersDiv.replaceChildren(...bufferDiv.children);
        if (!isUsersDivVisible) {
            usersDiv.style.right = `-${window.getComputedStyle(usersDiv).width}`;
            setTimeout(() => {
                usersDiv.style.visibility = 'visible';
            }, 300);
            usersDiv.style.right = `-${window.getComputedStyle(usersDiv).width}`;
        }
        if (isUsersDivVisible) {
            hideButton.textContent = '▶';
            usersDiv.insertBefore(hideButton, usersDiv.firstChild);
        } else {
            hideButton.textContent = '◀';
            hideButton.classList.add('hide-button-outside');
            document.querySelector('.profile').appendChild(hideButton);
        }

    } else {
        console.warn('No users were loaded into bufferDiv.');
    }
	let roomTitle = document.querySelector('.room-title');
	if (!roomTitle) {
	roomTitle = document.createElement('div');
	roomTitle.className = 'room-title';
	const roomTitleText = document.createElement('h2');
	roomTitleText.innerHTML = room.roomName;
	roomTitle.appendChild(roomTitleText);
	if (clientUser.admin || userId == room_cache.roomOwner) {
		const roomSettings = document.createElement('div');
		roomSettings.className = 'room-settings';
		const overlay = document.getElementById('overlay');
            	const closeOverlay = document.getElementById('closeOverlay');
		roomSettings.onclick = () => {
			overlay.innerHTML = `
                                    <div class="overlay-content">
                        <h2>Room Settings</h2>
                        <form class="join">
                            <input id="settingsName" placeholder="Room name" value="${room.roomName}">
                            <input id="settingsPassword" placeholder="Password(Current hidden)">
                            <div class="settingsOptions">
                            <h2 id="privateText">Private</h2>
                            <input id="settingsPrivate" ${room.isPrivate ? 'checked' : ''} type="checkbox">
                            <h2 id="maxUsersText">Max users</h2>
                            <input id="settingsMaxUsers" value="${room.maxUsers}" type="number" min="2" max="50">
                            </div>
                            <button type="submit" id="settingsSubmit">Submit</button>
                        </form>
                    </div>
                                `;
                        overlay.style.visibility = 'visible';
                        overlay.style.opacity = '1';
		}
		roomTitle.appendChild(roomSettings);
	}
	}
	usersDiv.insertBefore(roomTitle, usersDiv.firstChild);
    function toggleUserDivVisibility() {
        const isVisible = usersDiv.style.right === '0px';
        usersDiv.style.right = isVisible ? `-${window.getComputedStyle(usersDiv).width}` : '0';
        
        if (isVisible) {
            hideButton.textContent = '◀';
            hideButton.classList.add('hide-button-outside');
            document.querySelector('.inputDiv').style.width = '90vw';
            document.querySelector('.chat').style.width = '79vw';
            document.querySelector('.send-button').style.borderRight = 'none';
            document.querySelector('.profile').style.right = '1vw';
            document.querySelector('.profile').appendChild(hideButton);
            usersDiv.style.right = `-${window.getComputedStyle(usersDiv).width}`;
	    usersDiv.setAttribute('tabindex', '-1');
	    usersDiv.querySelectorAll('*').forEach(function(child){
    		child.setAttribute('tabindex', '-1');
	   });
        } else {
            hideButton.textContent = '▶';
            hideButton.classList.remove('hide-button-outside');
            const usersDivRect = usersDiv.getBoundingClientRect();
            const usersDivWidth = usersDivRect.width;
            const usersDivX = usersDivRect.left;
            const inputDivRect = document.querySelector('.inputDiv').getBoundingClientRect();
            const chatRect = document.querySelector('.chat').getBoundingClientRect();
            document.querySelector('.inputDiv').style.width = `${usersDivX - usersDivWidth - inputDivRect.left}px`;
            document.querySelector('.chat').style.width = `${usersDivX - usersDivWidth - chatRect.left}px`;
            document.querySelector('.send-button').style.borderRight = '4px solid var(--color-border)';
            document.querySelector('.profile').style.right = `-${window.getComputedStyle(document.querySelector('.profile')).width}`;
            usersDiv.insertBefore(hideButton, usersDiv.firstChild);
            usersDiv.style.right = '0';
        }
	let roomTitle = document.querySelector('.room-title');
	if (!roomTitle) {
	roomTitle = document.createElement('div');
	roomTitle.className = 'room-title';
	const roomTitleText = document.createElement('h2');
	roomTitleText.innerHTML = room.roomName;
	roomTitle.appendChild(roomTitleText);
	if (clientUser.admin || userId == room_cache.roomOwner) {
		const roomSettings = document.createElement('img');
		roomSettings.className = 'room-settings';
		roomSettings.src = '../UI/settings-icon.svg';
		roomTitle.appendChild(roomSettings);
	}
	}
	usersDiv.insertBefore(roomTitle, usersDiv.firstChild);
    }
}
	    let prevMessageList = [];
        async function loadMessages() {
            let chatDiv = document.querySelector('.chat');
            if (!chatDiv) {
                chatDiv = document.createElement('div');
                chatDiv.className = 'chat';
				chatDiv.setAttribute('tabindex', '0');
                document.querySelector('.home_menu').appendChild(chatDiv);
            }

            const bufferDiv = document.createElement('div');

            let inputDiv = document.querySelector('.inputDiv');
            let sendButton = document.querySelector('.send-button');
            if (!inputDiv) {
                inputDiv = document.createElement('div');
                inputDiv.className = 'inputDiv';
                inputField = document.createElement('input');
                inputField.type = 'text';
                inputField.placeholder = 'Type your message...';
                inputField.className = 'message-input';

                sendButton = document.createElement('button');
                sendButton.innerText = 'Send';
                sendButton.className = 'send-button';
                inputField.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    sendButton.click();
                }
            	});
		document.addEventListener('keydown', function(event) {
            		const key = event.key;
			let chat = document.querySelector('.chat');
			if (event.ctrlKey && event.key.toLowerCase() !== 'v') return;
    			if (event.altKey || event.metaKey) return;
	    		let input = document.querySelector('.message-input');
            		if (document.activeElement !== input && chat.contains(document.activeElement)) {
             		   input.focus();
			}
        	});
                inputDiv.appendChild(inputField);
                inputDiv.appendChild(sendButton);

                chatDiv.parentElement.appendChild(inputDiv);
            }
            sendButton.onclick = async () => {
                const messageText = inputField.value;
                if (messageText.trim() === '') {
                    alert('Please enter a message');
                    return;
                }
                try {
		    console.log('message send: sendbutton')
                    window.showLoadingScreen()
                    await api({
                        "userId": `${userId}`,
                        "token": `${token}`,
                        "roomId": `${currentRoomId}`,
                        "text": `${messageText}`
                    }, auth, "sendMessage");
                    inputField.value = '';
                } catch (error) {
                    window.hideLoadingScreen()
                    console.error('Error sending message:', error);
                    alert('Failed to send message =(');
                }
                waitForUpdateFlag = true;
            };

            let messages = (JSON.parse(await api({
                "userId": `${userId}`,
                "token": `${token}`,
                "roomId": `${currentRoomId}`
            }, auth, "getMessages")))['messages'];

            for (const message of messages) {
                let user;
                if (!user_cache[message.user]) {
                    try {
                        user = JSON.parse(await api({
                            "userId": `${userId}`,
                            "token": `${token}`,
                            "data": `${message.user}`,
                            "mode": 'fromuid'
                        }, auth, "getUser"));
                        user_cache[message.user] = user;
                    } catch (error) {
                        console.log("userGetError:", error);
                        continue;
                    }
                } else {
                    user = user_cache[message.user];
                }

                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';

                const userInfoDiv = document.createElement('div');
                userInfoDiv.className = 'user-info';

                if (!pfp_cache[message.user]) {
                    try {
                        const { data, error } = await supabaseClient.storage
                            .from("profilePictures")
                            .createSignedUrl(user.pfp, 3600);
                        if (!error) {
                            const pfp = document.createElement('img');
                            pfp_cache[message.user] = data.signedUrl;
                            pfp.src = pfp_cache[message.user];
                            pfp.draggable = false;
                            userInfoDiv.appendChild(pfp);
                        }
                    } catch (error) {
                        const pfp = document.createElement('img');
                        pfp.src = '../UI/account-placeholder.svg';
                        pfp.draggable = false;
                        userInfoDiv.appendChild(pfp);
                        console.error("Error fetching profile picture:", error);
                    }
                } else {
                    const pfp = document.createElement('img');
                    pfp.src = pfp_cache[message.user];
                    pfp.draggable = false;
                    userInfoDiv.appendChild(pfp);
                }
                if (!room_cache) {
                    try {
                        const { data, error } = await api({
                            "userId": `${userId}`,
                            "token": `${token}`,
                            "mode": "fromid",
                            "data": `${currentRoomId}`
                        }, auth, "getRoom");
                        room_cache = JSON.parse(data);
                    } catch (error) {
                        console.error("Error fetching roomData:", error);
                    }
                }
		

                const username = document.createElement('h2');
                username.textContent = user.username;
                username.style.color = user.admin
                    ? "var(--color-uninstall)"
                    : "var(--text-color1)";
                userInfoDiv.appendChild(username);
                const timestamp = document.createElement('h2');
                timestamp.className = 'message-timestamp';
                userInfoDiv.appendChild(timestamp);
                    const menuButton = document.createElement('button');
                    menuButton.className = 'menu-button';
                    menuButton.innerHTML = '&#x22EE;'; // vertical dots (⋮)

                    menuButton.onclick = (event) => {
                        event.stopPropagation();
                        closeAllDropdowns();
                        toggleDropdown(menuButton, message, inputField, sendButton, messageDiv);
                    };

                    userInfoDiv.appendChild(menuButton);

                    function toggleDropdown(button, message, inputField, sendButton, messageDiv) {
                        if (dropdown_cache) {
                            dropdown_cache.remove();
                            dropdown_cache = null;
                        } else {
                            let dropdown = document.createElement('div');
                            dropdown.className = 'dropdown-content';
				
                	    if (clientUser.admin || userId == message.user || userId == room_cache.roomOwner) {
                            const deleteButton = document.createElement('button');
                            deleteButton.innerText = 'Delete';
                            deleteButton.onclick = () => {
                                dropdown_cache.remove();
                                dropdown_cache = null;
                                overlay.innerHTML = `
                                    <div class="overlay-content">
                                        <h2>Are you sure you want to delete this message?</h2>
                                        <button id="confirmDelete">Yes</button>
                                        <button id="cancelDelete">No</button>
                                    </div>
                                `;
                                overlay.style.visibility = 'visible';
                                overlay.style.opacity = '1';

                                document.getElementById('confirmDelete').onclick = () => {
                                    deleteMessage(message.id);
                                    if (cancelButton_cache) {
                                        cancelButton_cache.click();
                                    }
                                    hideOverlay();
                                };

                                document.getElementById('cancelDelete').onclick = hideOverlay;

                                function hideOverlay() {
                                    overlay.style.opacity = '0';
                                    overlay.style.visibility = 'hidden';
                                }
                            };
                            dropdown.appendChild(deleteButton);
                            if (!editstatus_cache) {
                                const editButton = document.createElement('button');
                                editButton.innerText = 'Edit';
                                editButton.onclick = () => {
                                    dropdown_cache.remove();
                                    dropdown_cache = null;
                                    messageDiv.style.backgroundColor = 'var(--hover-color1)';
                                    var doc = new DOMParser().parseFromString(message.text, 'text/html');
                                    const originalText = doc.documentElement.textContent;
                                    inputField.value = originalText;
                                    inputField.focus();

                                    let editingStatusDiv = document.createElement('div');
                                    editingStatusDiv.className = 'editing-status';
                                    editstatus_cache = editingStatusDiv;

                                    const statusText = document.createElement('h2');
                                    statusText.innerText = 'Editing message...';
                                    editingStatusDiv.appendChild(statusText);
                                    sendButton.onclick = async () => {
                                        if (inputField.value != originalText) {
                                            editMessage(message.id, inputField.value, "");
                                        }
                                        cancelButton.click();
                                    };
                                    inputField.addEventListener('keydown', (event) => escCancelEdit(event, messageDiv));
                                    const cancelButton = document.createElement('button');
                                    cancelButton.innerText = 'x';
                                    cancelButton.className = 'cancelEdit';
                                    cancelButton.onclick = () => {
                                        inputField.value = '';
                                        messageDiv.style.backgroundColor = '';
                                        editingStatusDiv.remove();
                                        editstatus_cache = null;
                                        cancelButton_cache = null;
                                        sendButton.onclick = async () => {
                                            const messageText = inputField.value;
                                            if (messageText.trim() === '') {
                                                alert('Please enter a message');
                                                return;
                                            }
                                            try {
						console.log('message send: edit')
                                                window.showLoadingScreen()
                                                await api({
                                                    "userId": `${userId}`,
                                                    "token": `${token}`,
                                                    "roomId": `${currentRoomId}`,
                                                    "text": `${messageText}`
                                                }, auth, "sendMessage");
                                                inputField.value = '';
                                            } catch (error) {
                                                window.hideLoadingScreen()
                                                console.error('Error sending message:', error);
                                                alert('Failed to send message =(');
                                            }
                                            waitForUpdateFlag = true;
                                        };
                                        window.removeEventListener('keydown', escCancelEdit);
                                    };
                                    cancelButton_cache = cancelButton;
                                    editingStatusDiv.appendChild(cancelButton);

                                    document.body.appendChild(editingStatusDiv);
                                };
                                dropdown.appendChild(editButton);
                            }
			    }

                            const reportButton = document.createElement('button');
                            reportButton.innerText = 'Report Message';
                            reportButton.onclick = () => {
                                dropdown_cache.remove();
                                dropdown_cache = null;
                                overlay.innerHTML = `
                                    <div class="overlay-content">
                                        <h2>Report Message</h2>
                                        <textarea id="reportReason" placeholder="Reason for reporting"></textarea>
                                        <button id="submitReport">Submit</button>
                                        <button id="cancelReport">Cancel</button>
                                    </div>
                                `;
                                overlay.style.visibility = 'visible';
                                overlay.style.opacity = '1';

                                document.getElementById('submitReport').onclick = () => {
                                    const reason = document.getElementById('reportReason').value;
                                    if (reason.trim() === '') {
                                        alert('Please provide a reason for reporting');
                                        return;
                                    }
                                    report(message.id, reason, "message");
                                    hideOverlay();
                                };

                                document.getElementById('cancelReport').onclick = hideOverlay;

                                function hideOverlay() {
                                    overlay.style.opacity = '0';
                                    setTimeout(() => overlay.style.visibility = 'hidden', 300);
                                }
                            };
                            dropdown.appendChild(reportButton);
                            const reportUserButton = document.createElement('button');
                            reportUserButton.innerText = 'Report User';
                            reportUserButton.onclick = () => {
                                dropdown_cache.remove();
                                dropdown_cache = null;
                                overlay.innerHTML = `
                                    <div class="overlay-content">
                                        <h2>Report User</h2>
                                        <textarea id="reportUserReason" placeholder="Reason for reporting"></textarea>
                                        <button id="submitUserReport">Submit</button>
                                        <button id="cancelUserReport">Cancel</button>
                                    </div>
                                `;
                                overlay.style.visibility = 'visible';
                                overlay.style.opacity = '1';

                                document.getElementById('submitUserReport').onclick = () => {
                                    const reason = document.getElementById('reportUserReason').value;
                                    if (reason.trim() === '') {
                                        alert('Please provide a reason for reporting');
                                        return;
                                    }
                                    report(message.user, reason, "user");
                                    hideOverlay();
                                };

                                document.getElementById('cancelUserReport').onclick = hideOverlay;

                                function hideOverlay() {
                                    overlay.style.opacity = '0';
                                    setTimeout(() => overlay.style.visibility = 'hidden', 300);
                                }
                            };
                            dropdown.appendChild(reportUserButton);

                            document.querySelector('.home_menu').appendChild(dropdown);
                            const buttonRect = button.getBoundingClientRect();
                            dropdown.style.position = 'absolute';
                            dropdown.style.top = `${buttonRect.bottom}px`;
                            dropdown.style.left = `${buttonRect.left}px`;

                            dropdown_cache = dropdown;
                        }
                    }

                    document.addEventListener('click', closeAllDropdowns);

                    function closeAllDropdowns() {
                        document.querySelectorAll('.dropdown-content').forEach(dropdown => {
                            dropdown.remove();
                        });
                        dropdown_cache = null;
                    }
                messageDiv.appendChild(userInfoDiv);
                const body = document.createElement('p');
		const fragment = document.createDocumentFragment();
		const urlRegex = /(?<=^|[\s])((?:https?|ftp):\/\/[^\s<>"']+|www\.[^\s<>"']+|(?:https?|ftp):\/\/[^\s<>"']+)(?=[\s]|$)/gi;
		const emoteRegex = /<&(\d+):(\d+)>|&lt;&amp;(\d+):(\d+)&gt;/gm;
		const parts = replaceWithEmoji(message.text).split(urlRegex).filter(part => part !== "");
		
		for (let part of parts) {
		    const emoteMatches = [...part.matchAll(emoteRegex)];
		
		    for (const match of emoteMatches) {
		        const id = match[1] || match[3];
		        const folder = match[2] || match[4];
		        const cacheKey = `${folder}/${id}`;
		
		        let cachedEmote = emoteCache.find(emote => emote.emoteData === cacheKey);
		
		        if (!cachedEmote) {
		            console.log(`Fetching emote: ${cacheKey}`);
		            try {
		                const { data, error } = await supabaseClient.storage
		                    .from("emotes")
		                    .createSignedUrl(`${folder}/${id}.webp`, 60);
		
		                if (data && !error) {
		                    cachedEmote = { emoteData: cacheKey, url: data.signedUrl };
		                    emoteCache.push(cachedEmote);
		                } else {
		                    console.error("Error fetching emote:", error);
		                    continue;
		                }
		            } catch (e) {
		                console.error("Error fetching emote:", e);
		                continue;
		            }
		        } else {
		            console.log("Emote found in cache:", cachedEmote.url);
		        }
		
		        if (cachedEmote?.url) {
		            const emote = `<img class="emote" src="${cachedEmote.url}" alt="<${id}:${folder}>" draggable="false" oncontextmenu="return false;">`;
		            part = part.replace(match[0], emote);
		        }
		    }
		
		    if (urlRegex.test(part)) {
		        const link = document.createElement('a');
		        const doc = new DOMParser().parseFromString(part, 'text/html');
		        link.href = doc.documentElement.textContent;
		        link.target = "_blank";
		        link.rel = "noopener noreferrer";
		        link.textContent = doc.documentElement.textContent;
		        fragment.appendChild(link);
		
		        if (oembed_providers.length > 0) {
		            const origin = (new URL(doc.documentElement.textContent)).origin.toLowerCase().replace(/^www\./, '').replace(/\/$/, '');
		            const provider = oembed_providers.find(provider =>
		                provider.endpoints.some(endpoint =>
		                    endpoint.schemes?.some(pattern => {
		                        const regex = new RegExp(`^${pattern.replace(/\*/g, '.*')}$`);
		                        return regex.test(doc.documentElement.textContent);
		                    })
		                )
		            );
		            if (provider) {
		                try {
		                    const response = await fetch(`${provider.endpoints[0].url}?url=${encodeURIComponent(doc.documentElement.textContent)}&format=json`);
		                    const data = await response.json();
		                    const docHtml = new DOMParser().parseFromString(data.html, 'text/html');
		                    const embed = docHtml.querySelector('iframe');
		                    if (provider.provider_name === "YouTube") {
		                        embed.className = 'youtube-embed';
		                    }
		                    body.appendChild(embed);
		                } catch (e) {
		                    console.error("Error fetching or appending embed content:", e);
		                }
		            }
		        }
		    } else {
		        const tempDiv = document.createElement('div');
		        tempDiv.innerHTML = part; // Direct HTML embedding.
		        while (tempDiv.firstChild) {
		            fragment.appendChild(tempDiv.firstChild);
		        }
		    }
		}
		body.appendChild(fragment);
                let editedTag;
                if (message.edited) {
                    editedTag = document.createElement('span');
                    editedTag.className = 'edited-timestamp';
                }
                let updateTimestamps = () => {
                    timestamp.textContent = message.timestamp ? timeAgo(message.timestamp) : "";
                    if (message.edited) {
                        editedTag.textContent = ` (edited ${timeAgo(message.editedTimestamp)})`;
                    }
                }
                updateTimestamps();
                setInterval(updateTimestamps, 1000);
                messageDiv.appendChild(body);
                if (message.edited) {
                    body.appendChild(editedTag);
                }
		messageDiv.dataset.messageId = message.id;
                bufferDiv.appendChild(messageDiv);
            }
	    function objectDifference(list1, list2) {
		    return list1.filter(obj1 => 
		        !list2.some(obj2 => JSON.stringify(obj1) === JSON.stringify(obj2))
		    );
		}
		console.log(prevMessageList);
		if (prevMessageList.length > 0) {
		    console.log('Previous message list is not empty. Checking for changes...');
		    
		    const bufferArray = Array.from(bufferDiv.children);
		    console.log('Buffer array:', bufferArray);
		    
		    for (const message of bufferArray) {
		        console.log('Processing message:', message);
		        
		        const prev = Array.from(chatDiv.children).find(prevMessage => prevMessage.dataset.messageId === message.dataset.messageId);
		        console.log('Previous message found:', prev);
		        
		        if (prev) {
		            if (prev.dataset.messageId !== message.dataset.messageId || prev.textContent !== message.textContent) {
			            console.log('Updating changed message:', message);
			            chatDiv.replaceChild(message, prev);
			        }
		        } else {
			    console.log('Appending new message:', message);
			    if(chatDiv.scrollHeight - chatDiv.scrollTop - chatDiv.clientHeight < 175) {
				    requestAnimationFrame(() => {
				            console.log('Scrolling to the bottom...');
				            document.querySelector('.chat').scrollTop = document.querySelector('.chat').scrollHeight;
				    });
			    }
			    chatDiv.appendChild(message);
			}
		    }
		    const bufferIds = new Set(bufferArray.map(msg => msg.dataset.messageId));
		    for (const message of Array.from(chatDiv.children)) {
		        if (!bufferIds.has(message.dataset.messageId)) {
		            console.log('Removing deleted message:', message);
		            chatDiv.removeChild(message);
		        }
		    }
		    
		    prevMessageList = bufferArray;
		} else {
		    console.log('Previous message list is empty. Replacing all children...');
		    prevMessageList = [...bufferDiv.children];
		    chatDiv.replaceChildren(...bufferDiv.children);
		    requestAnimationFrame(() => {
		        console.log('Scrolling to the bottom...');
		        document.querySelector('.chat').scrollTop = document.querySelector('.chat').scrollHeight;
		    });
		}
        }

        if (currentRoomId) {
	let room_error;
	try {
		const { data, error } = await api({
		    "userId": `${userId}`,
		    "token": `${token}`,
		    "mode": "fromid",
		    "data": `${currentRoomId}`
		}, auth, "getRoom");
		if (error) {
			room_error = error;
		}
	    } catch (error) {
		console.error("Error fetching room:", error);
		room_error = error;
	    }
	    if (!room_error) {
	    room_found = true;
            await loadMessages()
            let roomChannel = supabaseClient
                .channel('messages')
                .on(
                    'postgres_changes',
                    {
                        event: '*',
                        schema: 'public',
                        table: 'rooms',
                        filter: `id=eq.${currentRoomId}`
                    },
                    async (payload) => {
                        try {
                            await loadMessages();
                            if (waitForUpdateFlag) {
                                window.hideLoadingScreen();
                                inputField.focus();
                                waitForUpdateFlag = false;
                            }
                            console.log('Room refreshed');
                        } catch (error) {
                            console.error('Error refreshing room:', error);
                        }
                    }
                )
                .subscribe((status) => {
                    console.log('Room subscription status:', status);
                });
            
let channel = supabaseClient.channel(`room-${currentRoomId}`, {
    config: {
        presence: {
            key: 'users',
        },
    },
});

subscribeToChannel();
let isActive = true;
let inactivityTimer;
function resetInactivityTimer() {
    if(!isActive) {
	console.log('active')
    isActive = true;
    updateStatus()
    }
    clearTimeout(inactivityTimer);
    inactivityTimer = setTimeout(() => {
	    console.log('idle')
        isActive = false;
		updateStatus()
    }, 3.5 * 60 * 1000);
}
document.addEventListener('keydown', resetInactivityTimer);
document.addEventListener('keyup', resetInactivityTimer);
document.addEventListener('mousemove', resetInactivityTimer);
document.addEventListener('click', resetInactivityTimer);
document.addEventListener('mousedown', resetInactivityTimer);
document.addEventListener('mouseup', resetInactivityTimer);
document.addEventListener('touchstart', resetInactivityTimer);
document.addEventListener('touchmove', resetInactivityTimer);
document.addEventListener('touchend', resetInactivityTimer);

let isTyping = false;
let typingTimeout = 3000;
let typingTimer;
function setTyping() {
if(!isTyping) {
console.log('typing')
isTyping = true;
updateStatus();
}
clearTimeout(typingTimer);
typingTimer = setTimeout(() => {
	console.log('not typing')
        isTyping = false;
	updateStatus()
}, typingTimeout);
}
const messageInput = document.querySelector('.message-input');
if (messageInput) {
    messageInput.addEventListener('input', setTyping);
}
resetInactivityTimer();
		
let presenceTrackStatus
async function updateStatus() {
    let userStatus = {
        user: userId,
        online_at: new Date().toISOString(),
        status: isActive,
        typing: isTyping,
    };
    try {
        presenceTrackStatus = await channel.track(userStatus);
        if (presenceTrackStatus.error) {
            console.error('Presence track error:', presenceTrackStatus.error);
        }
    } catch (error) {
        console.error('Failed to track presence:', error);
    }
}


function subscribeToChannel() {
    channel.subscribe(async (status) => {
    if (status === 'SUBSCRIBED') {
        console.log('Successfully subscribed to room-' + currentRoomId, 'channel.');
        await updateStatus();
        updateOnlineUsers(channel.presenceState());
    } else if (status === 'CLOSED') {
        reconnectChannel();
    }
});


channel.on('presence', { event: 'sync' }, () => {
        const currentPresence = channel.presenceState();
        updateOnlineUsers(currentPresence);
});

    channel.on('presence', { event: 'join' }, ({ key, currentPresences }) => {
        console.log(`${key} joined`, currentPresences);
    });

    channel.on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
        console.log(`${key} left`, leftPresences);
    });
}

function updateOnlineUsers(presenceState) {
    const users = Object.values(presenceState).flatMap(userPresences =>
    userPresences.map(p => ({
        user: p.user,
        status: p.status,
        typing: p.typing,
    }))
);
    console.group(`updateOnlineUsers called`);
    console.log(presenceState,channel);
    console.log('Current users:', users);
    console.groupEnd();
    if(!users.some(userStatus => userStatus.user === userId)) {
	users.push({
		 user:userId,
		 status:true,
		 typing:false
		})
    }
    user_statuses = users;
    loadUsers();
}

async function reconnectChannel() {
    try {
        await channel.unsubscribe();
        channel = supabaseClient.channel(`room-${currentRoomId}`, {
            config: {
                presence: { key: 'users' }
            }
        });
        subscribeToChannel();
    } catch (error) {
        console.error('Failed to reconnect:', error);
    }
}

        } else {
		loadHome();
	}
	}else {
		loadHome();
	}
	    async function friendUser(data) {
            try {
                window.showLoadingScreen()
                const response = await api({
                    "userId": `${userId}`,
                    "token": `${token}`,
                    "data": `${data}`,
                }, auth, "addFriend");
                const state = JSON.parse(response);

                switch (state.message) {
                    case "Request already exists":
                        alert("Request already exists");
                        break;
		    case "Blocked":
                        alert("You have been blocked by this user");
                        break;
		    case "Already friends":
                        alert("Already friends");
                        break;
                    case "User not found":
                        alert("User not found");
                        break;
                    case "Sent":
                        alert("sent request")
                        return
                        break;
                    default:
                        alert("An unknown error occurred =(");
                        break;
                }
                window.hideLoadingScreen();
            } catch (error) {
                window.hideLoadingScreen();
                console.error("Error sending:", error);
                alert("Failed to send =(");
            }
        }
	async function loadHome() {
		const home = document.createElement('div');
		home.className = 'home';
		const friends = document.createElement('div');
		friends.className = 'friends';
		const userbox = document.createElement('input');
		userbox.className = 'userbox';
		const userboxbutton = document.createElement('button');
		userboxbutton.className = 'userboxbutton';
		userboxbutton.textContent = 'Send friend request';
		userboxbutton.onclick = () => {
			const username = document.querySelector('.userbox').value;
			friendUser(username);
			document.querySelector('.userbox').value = '';
		};
		const frenadddiv = document.createElement('div');
		frenadddiv.className = 'frenadddiv';
		frenadddiv.appendChild(userbox);
		frenadddiv.appendChild(userboxbutton);
		home.appendChild(frenadddiv);
		home.appendChild(friends);
		document.querySelector('.home_menu').appendChild(home);
	}
        loadRooms();
        setInterval(loadRooms, 7000)
    </script>
</body>

</html>
